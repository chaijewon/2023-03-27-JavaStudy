package com.sist.exception;
/*
 *    3. final 클래스 => 종단 클래스 (java.lang)
 *    ----------- 확장을 할 수 없다 (있는 그대로 사용) => 상속을 내리지 못한다 
 *                상위클래스가 될 수 없다
 *    java.lang 
 *    java.util
 *    java.io
 *    java.net
 *    java.text 
 *    ------------- 기본 라이브러리 
 *    java.sql , javax.http.servlet.* javax.xml....
 *    오라클       브러우저...
 *    
 *    4. 오버라이딩 (상속의 기본) => 변경해서 사용 (다형성)
 *       객체지향의 3대 요소 
 *         1. 데이터 보호 목적 
 *            캡슐화 : 변수를 은닉화 => 메소드를 통해서 접근이 가능하게 만든다 
 *                   -----------                ---------
 *                      private                   public 
 *                  => 변수는 2가지 기능만 수행 
 *                     메모리 저장 / 메모리에서 데이터 읽기 
 *                     --------   ------------------
 *                      setter         getter
 *                  => 모든 멤버변수 : private 
 *                  => 모든 메소드(생성자) : public => 다른 클래스와 연결이 가능 
 *             접근 지정어 
 *             ---------
 *             1) private  : 자신의 클래스에서만 사용이 가능 (은닉화)
 *                           다른 클래스에서는 접근이 불가능 
 *             2) default : 같은 패키지에서만 접근이 가능 
 *             3) public : 공개(패키지 상관없이 모든 클래스에 접근이 가능)
 *         2. 재사용하는 목적 : 상속 , 포함  ==> 클래스 크기 결정 => 형변환
 *            class A
 *            class B extends A => A가 가지고 있는 모든 내용을 가지고 온다 
 *                    ------- A의 내용을 변경해서 사용,추가가 가능하다 
 *                            라이브러리 => 프로그램에 맞지 않는 경우 (수정)
 *            =============> A(상속을 내린 클래스) > B(상속을 받은 클래스)
 *              => A a=new A()
 *                 B b=new B()
 *                 A c=new B() => 묵시적 형변환 (자동)
 *                   ------> 추상클래스/인터페이스 (메모리 할당이 안된다)
 *                           ----------------
 *                           메모리 할당시에 상속을 받은 클래스를 이용해서 메모리 할당을 한다
 *                           미완성 클래스(메소드가 구현이 안된 상태)
 *                                      --------------------
 *                           => 설계 , 같은 기능 (처리를 프로그램에 맞게 할때) 
 *                                    버튼 클릭 , 마우스 클릭 ...
 *                                    게시판 : 글쓰기 
 *                 B d=(B)c; => 명시적 형변환 (강제)
 *                 --------- 라이브러리에서 많이 사용 
 *                 
 *                 => 클래스를 저장해서 관리 (클래스) => Collection
 *                 'A' 'BBBBB' 
 *                 1byte 5byte
 *                 'A' 'BBBBBB' ==> 1000byte
 *            class A
 *            {
 *               B b=new B(); // 특별한 경우가 아니면 재정의하지 않는다 
 *            }
 *            class B
 *         3. 수정,추가 목적 (유지보수)
 *            수정(오버라이딩) 추가(오버로딩) => 메소드관련 
 *            
 *            ---------------------------------------
 *                         오버로딩       오버라이딩 
 *            ---------------------------------------
 *            관계          한개의 클래스   상속관계 
 *                         상속관계
 *            ---------------------------------------
 *            메소드명       동일          동일
 *            ---------------------------------------
 *            매개변수      갯수나          동일
 *                        데이터형이 다르다
 *            ---------------------------------------
 *            리턴형        관계없음        동일
 *            ---------------------------------------
 *            접근지정어     관계없음       확장가능 
 *            ---------------------------------------
 *            사용처        생성자         인터페이스/추상클래스
 *            ---------------------------------------
 *            *** 상속 
 *            1) 호출 ==> 상위클래스의 생성자가 먼저 호출 (기본생성자)
 *               class A
 *               {
 *                   => public A(){}
 *                   public A(int a){}
 *               }
 *               class B extends A
 *               { 
 *                   public B(int a,int b){}
 *               }
 *               
 *               B b=new B();
 *                  => new A() => new B()
 *            2) 예외조건 : static , 생성자 , 초기화블럭 , private
 *            
 *            class A
 *            class B extends A
 *            class D extends B
 *            class E extends B
 *            -------------------
 *            A a=new A()
 *            A a=new B()
 *            B b=new B()
 *            B b=new D()
 *            B b=new E()
 *            ------------
 *            B b=(B)new A(); => ClassCastException
 *            ---------------- (X)
 *            A a=new B();
 *            B b=(B)a;
 *      ------------------------------------------------
 *      클래스의 종류 
 *      = 추상클래스 
 *      = 인터페이스 => 추상클래스의 단점을 보완 (클래스와 동일하게 취급)
 *        ** 클래스(단일) / 인터페이스(다중)
 *      --- 설계도(구현이 안된 상태) => 미완성 클래스 (자신이 메모리 할당을 할 수 없다)
 *      --- 여러개의 관련된 클래스를 모아서 한개의 객체명으로 제어 
 *      ---------------------------------------------------
 *                     추상클래스              인터페이스
 *      ---------------------------------------------------
 *      상속관계        단일 상속               다중 상속 
 *      ---------------------------------------------------
 *      상속키워드      extends               implements
 *      ---------------------------------------------------
 *      멤버변수       인스턴스변수             상수형변수만 사용
 *                   정적변수 
 *      ---------------------------------------------------
 *      메소드        구현된메소드            구현이 안된 메소드
 *                   구현이 안된 메소드
 *      ---------------------------------------------------
 *      기법          오버라이딩             오버라이딩 
 *      ---------------------------------------------------
 *      형식 
 *      
 *         추상클래스 
 *         [접근지정어] abstract class ClassName
 *         {
 *              ------------------------
 *               변수 
 *                 인스턴스 변수
 *                 static 변수
 *              ------------------------
 *               메소드 
 *                 구현된 메소드
 *                 [접근지정어] 리턴형 메소드명(매개변수..)
 *                 {
 *                 }
 *                 구현이 안된 메소드(선언)
 *                 [접근지정어] abstract 리턴형 메소드명(매개변수..);
 *                           ---------
 *              ------------------------
 *                 생성자 , 오버로딩이 가능 
 *              ------------------------
 *         }
 *         
 *         인터페이스
 *         [접근지정어] interface Interface명{
 *             -----------------------
 *              변수선언 (성수형변수)
 *                int a=10; => 값을 명시적으로 지정 
 *                => public static final int a=10;
 *                   -------------------
 *             -----------------------
 *              구현이 안된 메소드 목록
 *              void display();
 *                => public abstract void display();
 *                   ---------------
 *             -----------------------
 *              구현한 메소드 목록 
 *              default void aaa(){}
 *                => public default void aaa(){}
 *              static void bbb(){}
 *                => public static void bbb(){}
 *             -----------------------
 *         }
 *         ==> 인터페이스는 변수나 메소드가 public (연결목적 => 언제든 연결이 가능)
 *      ---------------------------------------------------
 *      
 *      상속 
 *               extends
 *      interface ===> interface 
 *               implements
 *      interface ===> class
 *      
 *      다중 상속
 *      class A implements 인터페이스,인터페이스.....
 *      
 *      
 *            
 *            
 *            
 */
import java.util.*;
class AAA
{
	public void aaa() {}
	public AAA() {}
	int a=10;
	public String toString() {
		return "";
	}
}
abstract class C
{
	C(){}
	C(int a){}
}
class A
{
	int a=10;
	String name="홍길동";
	// A(){}
	public A() {}
	public A(int a)
	{
		this.a=a;
	}
}
// new A() => new A(10)
class B extends A
{
	int b=20;
	public B()
	{
		
		
	}
}
// A a=new B() ==> A에 있는 데이터만 사용 , 메소드는 변경된 것만 사용 
// 하위클래스에서 추가된 메소드 ,변수는 사용할 수 없다 
// B b=new B()
public class 정리_7장{

	public static void main(String[] args) {
		// TODO Auto-generated method stub
        //B b=(B)new A();
		/*String s1="Hello";
		String s2="Hello";
		String s3=new String("Hello");
		
		if(s1==s2)
			System.out.println("같다(참조주소)");*/
		Object o=new AAA();
		
		AAA a=(AAA)o;
		
	}

}
